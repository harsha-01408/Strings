Title: Minimum Flips to Avoid Three Consecutive Identical Characters

You are given a string s consisting only of the characters 'a' and 'b'.
In one operation, you may flip a single character: change 'a' → 'b' or 'b' → 'a'.

Task
Find the minimum number of operations required so that the final string does NOT
contain three consecutive identical characters (i.e., no substring "aaa" or "bbb").

Input
- A single line containing the string s (1 ≤ |s| ≤ 2 * 10^5), s[i] ∈ {'a','b'}.

Output
- A single integer: the minimum number of flips.

Hint
Let the string be decomposed into runs of equal characters with lengths L1, L2, ….
The answer is:  sum over all runs of floor(Li / 3).

Examples
1)
Input
aaabbb
Output
2
Explanation
Runs have lengths 3 and 3 → floor(3/3)+floor(3/3)=2. One optimal result: "aabab b".

2)
Input
abba
Output
0
Explanation
There is no "aaa" or "bbb" already.

3)
Input
aaaa
Output
1
Explanation
Run length 4 → floor(4/3)=1; flip one character to break into ≤2-length segments.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Smallest Anagram Period

You are given a string input_str of lowercase English letters.

Definition:
input_str is said to be formed from a base string s if input_str can be partitioned into consecutive substrings s1, s2, …, sm such that:
• Every full substring (s1, s2, …, s_{m-1}) is a perfect anagram of s (same letter counts).
• The last substring sm may be a partial of s: |sm| ≤ |s| and, for each letter c, count_sm(c) ≤ count_s(c).

Task:
Find the length L = |s| of the smallest possible base string s that can generate input_str in this way.

Input Format:
• One line containing input_str.

Output Format:
• A single integer: the smallest valid L.

Constraints:
• 1 ≤ |input_str| ≤ 1e5
• input_str consists only of 'a'–'z'

Example 1
Input
abcbcacba
Output
3

Example 2
Input
bbaaabababaabb
Output
4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

String Operation XOR

You are given an integer n and a binary string s of length n (consisting only of characters '0' and '1').

In one move, you may choose two adjacent characters s[i] and s[i+1] and replace BOTH of them according to the following rule:

00 -> 00
11 -> 00
01 -> 11
10 -> 11

(That is, you compute the XOR of the two bits and write that result in both positions.)

Your goal is to make the entire string consist only of '0' characters.

Return the minimum number of moves required to transform s into a string of all '0'.

If it is impossible to make all characters '0', return -1.

Example:
n = 7
s = "1101110"
Output: 4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Smaller Than Reverse – findMinimumOperations

You are given a string s consisting of lowercase English letters.

Define:
  rev = reverse(s)   (the string s reversed)

Your goal:
You want to transform s (by swapping characters) so that:
  s is lexicographically smaller than rev
i.e., s < rev in dictionary order.

Operation allowed:
In one operation, you may choose any two indices i and j (0 ≤ i, j < |s|) and swap the characters s[i] and s[j].

You may perform this operation any number of times.

Task:
Return the minimum number of such swaps needed so that in the final string s, the condition
  s < reverse(s)
holds.

If it is impossible to make s lexicographically smaller than its reverse (for example, s = "aaa", where every permutation equals its reverse), return -1.

Examples:

Example 1:
Input:
s = "psnab"
Output:
1

Example 2:
Input:
s = "aaa"
Output:
-1


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Description
Cow Bessie is learning string operations. She constructs new strings step by step using the following rules:

S(0) = "moo"

S(1) = S(0) + "m" + "ooo" + S(0)
     = "moo" + "m" + "ooo" + "moo"
     = "moomooomoo"

S(2) = S(1) + "m" + "oooo" + S(1)
     = "moomooomoo" + "m" + "oooo" + "moomooomoo"
     = "moomooomoomoooomoomooomoo"

…

Bessie keeps generating strings in this way, until the length of the latest string is at least the given integer N.

From the construction above, we can see that the k-th string is formed by:
S(k) = S(k−1) + "m" + (k+2 copies of 'o') + S(k−1)

Now, given an integer N (1 ≤ N ≤ 10^9), determine whether the N-th character (1-indexed) of this final string is the letter 'm' or 'o'.

Input Format
A single integer N.

Output Format
A single character: either 'm' or 'o'.

Sample Input
11

Sample Output
m

Explanation:
S(0) = "moo" has length 3, so it’s too short for position 11.
S(1) has length 10, still too short.
S(2) has length 25, which is enough. The 11th character of S(2) is 'm', so the answer is 'm'.

Constraints
1 ≤ N ≤ 10^9


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

String Compression with Frequency Limit

You are given a string s consisting of lowercase English letters and an integer k (k >= 2).

You repeatedly perform the following operation on the string:

    - If there exists a group of exactly k equal and adjacent characters,
      remove all k characters from the string.

After a removal, the string closes up, and new groups of k equal adjacent
characters may form. You must keep applying this operation as long as
it is possible.

Return the final string after all possible removals have been performed.

--------------------------------------------------
Examples:

1) s = "abbcccb", k = 3

   - "abbcccb"
     Here "ccc" is a group of 3 equal adjacent characters → remove it:
       "abbcccb" → "abbb"
   - Now in "abbb", we have "bbb" as a group of 3 equal adjacent characters → remove it:
       "abbb" → "a"
   - No more groups of size 3 exist.

   Output: "a"


2) s = "aba", k = 2

   - "aba"
     There is no group of 2 equal adjacent characters.
     So the string remains unchanged.

   Output: "aba"

--------------------------------------------------
Goal:

Implement a function that, given s and k, returns the resulting string
after repeatedly removing all possible groups of k equal adjacent characters.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimum Disjoint Segments After Removing One Character

You are given a string s consisting of lowercase English letters.

You must perform the following operation exactly once:
- Choose any lowercase English character ch, and remove ALL occurrences of ch from s.
  (If ch does not appear in s, the string remains unchanged.)

After the removal, partition the resulting string into the minimum number of non-empty,
pairwise disjoint contiguous segments such that in each segment, no character repeats
(i.e., every segment contains only distinct characters).

Return the minimum possible number of segments over all choices of ch.

Notes:
- Segments must be contiguous substrings that together cover the entire resulting string.
- Each segment must be non-empty.
- If the resulting string becomes empty, the answer is 0.

Example:
Input:  s = "abac"
Remove 'a' -> "bc"  -> 1 segment ("bc")
Remove 'b' -> "aac" -> 2 segments ("a", "ac")
Answer: 1

Constraints:
- 1 <= |s| <= 2 * 10^5
- s contains only 'a' to 'z'

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given a binary string S of length N.

You may perform the following operation any number of times:
- Choose an index i such that 1 < i < |S| (i is not the first or last position),
- and S[i-1] = S[i+1].
  If this condition holds, delete the character S[i] from the string.
  The remaining left part S[1..i-1] and right part S[i+1..|S|] are concatenated.

Each operation decreases the length of the string by 1.

For each test case, determine the minimum possible length of the string after performing operations optimally.
Print that minimum length.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Almost Matching Substrings

Given a string s (lowercase English letters) and an integer k (0-based index),
count the number of ordered pairs of substrings (A, B) of s such that:

1) A and B have the same length L, and L > k
2) For every position x in [0, L-1] where x != k:  A[x] = B[x]
3) At position k:  A[k] != B[k]

Two substrings are identified by their start and end indices (so substrings taken
from different positions are considered different even if their contents are equal).

Return the total number of such ordered pairs (A, B).

Input Format (custom testing)
- First line: string s
- Second line: integer k

Output Format
- Print a single integer: the number of ordered pairs of almost-matching substrings.

Constraints
- 1 <= |s| <= 200
- 0 <= k < |s|
- s contains only 'a' to 'z'

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

A student compresses big words by removing groups of consecutive equal characters.
An operation consists of choosing a group of k consecutive equal characters and
removing them. The student performs this operation as long as possible.

Given a string word (lowercase English letters) and an integer k, determine the
final word after all possible operations are performed.

Return the final word (it is guaranteed to be unique and non-empty).

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
