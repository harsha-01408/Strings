Title: Minimum Flips to Avoid Three Consecutive Identical Characters

You are given a string s consisting only of the characters 'a' and 'b'.
In one operation, you may flip a single character: change 'a' → 'b' or 'b' → 'a'.

Task
Find the minimum number of operations required so that the final string does NOT
contain three consecutive identical characters (i.e., no substring "aaa" or "bbb").

Input
- A single line containing the string s (1 ≤ |s| ≤ 2 * 10^5), s[i] ∈ {'a','b'}.

Output
- A single integer: the minimum number of flips.

Hint
Let the string be decomposed into runs of equal characters with lengths L1, L2, ….
The answer is:  sum over all runs of floor(Li / 3).

Examples
1)
Input
aaabbb
Output
2
Explanation
Runs have lengths 3 and 3 → floor(3/3)+floor(3/3)=2. One optimal result: "aabab b".

2)
Input
abba
Output
0
Explanation
There is no "aaa" or "bbb" already.

3)
Input
aaaa
Output
1
Explanation
Run length 4 → floor(4/3)=1; flip one character to break into ≤2-length segments.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Smallest Anagram Period

You are given a string input_str of lowercase English letters.

Definition:
input_str is said to be formed from a base string s if input_str can be partitioned into consecutive substrings s1, s2, …, sm such that:
• Every full substring (s1, s2, …, s_{m-1}) is a perfect anagram of s (same letter counts).
• The last substring sm may be a partial of s: |sm| ≤ |s| and, for each letter c, count_sm(c) ≤ count_s(c).

Task:
Find the length L = |s| of the smallest possible base string s that can generate input_str in this way.

Input Format:
• One line containing input_str.

Output Format:
• A single integer: the smallest valid L.

Constraints:
• 1 ≤ |input_str| ≤ 1e5
• input_str consists only of 'a'–'z'

Example 1
Input
abcbcacba
Output
3

Example 2
Input
bbaaabababaabb
Output
4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

String Operation XOR

You are given an integer n and a binary string s of length n (consisting only of characters '0' and '1').

In one move, you may choose two adjacent characters s[i] and s[i+1] and replace BOTH of them according to the following rule:

00 -> 00
11 -> 00
01 -> 11
10 -> 11

(That is, you compute the XOR of the two bits and write that result in both positions.)

Your goal is to make the entire string consist only of '0' characters.

Return the minimum number of moves required to transform s into a string of all '0'.

If it is impossible to make all characters '0', return -1.

Example:
n = 7
s = "1101110"
Output: 4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
